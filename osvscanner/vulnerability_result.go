package osvscanner

import (
	"fmt"
	"math"
	"sort"
	"strings"
	"web-scan-worker/internal/models"
	"web-scan-worker/osvscanner/grouper"
	"web-scan-worker/osvscanner/osv"

	gocvss20 "github.com/pandatix/go-cvss/20"
	gocvss30 "github.com/pandatix/go-cvss/30"
	gocvss31 "github.com/pandatix/go-cvss/31"
	gocvss40 "github.com/pandatix/go-cvss/40"
)

// buildVulnerablityResults takes the responses from the OSV API and the deps.dev API
// and converts this into a VulnerabilityResults. As part is this, it groups
// vulnerability information by source location.
// TODO: This function is getting long, we should refactor it
func buildVulnerabilityResults(
	packages []scannedPackage,
	vulnsResp *osv.HydratedBatchedResponse,
) models.VulnerabilityResults {
	results := models.VulnerabilityResults{
		Results: []models.PackageSource{},
	}
	groupedBySource := map[models.SourceInfo][]models.PackageVulns{}
	for i, rawPkg := range packages {
		var pkg models.PackageVulns
		includePackage := false

		if rawPkg.Commit != "" {
			pkg.Package.Commit = rawPkg.Commit
			pkg.Package.Name = rawPkg.Name
		}

		if rawPkg.Version != "" && rawPkg.Ecosystem != "" {
			pkg.Package = models.PackageInfo{
				Name:      rawPkg.Name,
				Version:   rawPkg.Version,
				Ecosystem: string(rawPkg.Ecosystem),
			}
		}

		pkg.DepGroups = rawPkg.DepGroups

		if len(vulnsResp.Results[i].Vulns) > 0 {
			includePackage = true
			pkg.Vulnerabilities = vulnsResp.Results[i].Vulns
			pkg.Groups = grouper.Group(grouper.ConvertVulnerabilityToIDAliases(pkg.Vulnerabilities))
			for i, group := range pkg.Groups {
				pkg.Groups[i].MaxSeverity = maxSeverity(group, pkg)
			}
		}
		if includePackage {
			groupedBySource[rawPkg.Source] = append(groupedBySource[rawPkg.Source], pkg)
		}
	}

		for source, packages := range groupedBySource {
		results.Results = append(results.Results, models.PackageSource{
			Source:   source,
			Packages: packages,
		})
	}

	sort.Slice(results.Results, func(i, j int) bool {
		if results.Results[i].Source.Path == results.Results[j].Source.Path {
			return results.Results[i].Source.Type < results.Results[j].Source.Type
		}

		return results.Results[i].Source.Path < results.Results[j].Source.Path
	})

	return results
}

func maxSeverity(group models.GroupInfo, pkg models.PackageVulns) string {
	var maxSeverity float64 = -1
	for _, vulnID := range group.IDs {
		var severities []models.Severity
		for _, vuln := range pkg.Vulnerabilities {
			if vuln.ID == vulnID {
				severities = vuln.Severity
			}
		}
		score, _, _ := calculateOverallScore(severities)
		maxSeverity = math.Max(maxSeverity, score)
	}

	if maxSeverity < 0 {
		return ""
	}

	return fmt.Sprintf("%.1f", maxSeverity)
}

func calculateOverallScore(severities []models.Severity) (float64, string, error) {
	maxScore := -1.0
	maxRating := "UNKNOWN"

	for _, severity := range severities {
		score, rating, err := calculateScore(severity)
		if err != nil {
			return -1, "UNKNOWN", err
		}
		if score > maxScore {
			maxScore = score
			maxRating = rating
		}
	}

	return maxScore, maxRating, nil
}

func calculateScore(severity models.Severity) (float64, string, error) {
	score := -1.0
	rating := "UNKNOWN"
	var err error
	switch severity.Type {
	case models.SeverityCVSSV2:
		var vec *gocvss20.CVSS20
		vec, err = gocvss20.ParseVector(severity.Score)
		if err == nil {
			score = vec.BaseScore()
			// CVSS 2.0 does not define a rating, use CVSS 3.0's rating instead
			rating, err = gocvss30.Rating(score)
		}
	case models.SeverityCVSSV3:
		switch {
		case strings.HasPrefix(severity.Score, "CVSS:3.0"):
			var vec *gocvss30.CVSS30
			vec, err = gocvss30.ParseVector(severity.Score)
			if err == nil {
				score = vec.BaseScore()
				rating, err = gocvss30.Rating(score)
			}
		case strings.HasPrefix(severity.Score, "CVSS:3.1"):
			var vec *gocvss31.CVSS31
			vec, err = gocvss31.ParseVector(severity.Score)
			if err == nil {
				score = vec.BaseScore()
				rating, err = gocvss31.Rating(score)
			}
		}
	case models.SeverityCVSSV4:
		var vec *gocvss40.CVSS40
		vec, err = gocvss40.ParseVector(severity.Score)
		if err == nil {
			score = vec.Score()
			rating, err = gocvss40.Rating(score)
		}
	}

	return score, rating, err
}